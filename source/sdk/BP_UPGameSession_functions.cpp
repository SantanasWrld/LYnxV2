#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_UPGameSession

#include "Basic.hpp"

#include "BP_UPGameSession_classes.hpp"
#include "BP_UPGameSession_parameters.hpp"


namespace SDK
{

// Function BP_UPGameSession.BP_UPGameSession_C.ApplyCustomAmountModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InMin                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   InMax                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<E_Spawnable>&                    Spawnables_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double*                                 Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::ApplyCustomAmountModifier(int32 InMin, int32 InMax, TArray<E_Spawnable>& Spawnables_0, double* Min, double* Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "ApplyCustomAmountModifier");

	Params::BP_UPGameSession_C_ApplyCustomAmountModifier Parms{};

	Parms.InMin = InMin;
	Parms.InMax = InMax;
	Parms.Spawnables_0 = std::move(Spawnables_0);

	UObject::ProcessEvent(Func, &Parms);

	Spawnables_0 = std::move(Parms.Spawnables_0);

	if (Min != nullptr)
		*Min = Parms.Min;

	if (Max != nullptr)
		*Max = Parms.Max;
}


// Function BP_UPGameSession.BP_UPGameSession_C.ApplyCustomTimeModifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  InMin                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  InMax                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::ApplyCustomTimeModifier(double InMin, double InMax, E_Spawnable Spawnable, double* Min, double* Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "ApplyCustomTimeModifier");

	Params::BP_UPGameSession_C_ApplyCustomTimeModifier Parms{};

	Parms.InMin = InMin;
	Parms.InMax = InMax;
	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Min != nullptr)
		*Min = Parms.Min;

	if (Max != nullptr)
		*Max = Parms.Max;
}


// Function BP_UPGameSession.BP_UPGameSession_C.CheckDeadPlayers
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::CheckDeadPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "CheckDeadPlayers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.EndSession
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::EndSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "EndSession");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.ExecuteUbergraph_BP_UPGameSession
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::ExecuteUbergraph_BP_UPGameSession(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "ExecuteUbergraph_BP_UPGameSession");

	Params::BP_UPGameSession_C_ExecuteUbergraph_BP_UPGameSession Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetInteractNoise
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   NoiseOnInteract                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 NoiseRange                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetInteractNoise(bool* NoiseOnInteract, double* NoiseRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetInteractNoise");

	Params::BP_UPGameSession_C_GetInteractNoise Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NoiseOnInteract != nullptr)
		*NoiseOnInteract = Parms.NoiseOnInteract;

	if (NoiseRange != nullptr)
		*NoiseRange = Parms.NoiseRange;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetRandomCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 ABP_UPGameSession_C::GetRandomCount(double Min, double Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetRandomCount");

	Params::BP_UPGameSession_C_GetRandomCount Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetRandomSpawnable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<E_Spawnable>&              Spawnables_0                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// E_Spawnable*                            Spawnable                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetRandomSpawnable(const TArray<E_Spawnable>& Spawnables_0, E_Spawnable* Spawnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetRandomSpawnable");

	Params::BP_UPGameSession_C_GetRandomSpawnable Parms{};

	Parms.Spawnables_0 = std::move(Spawnables_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Spawnable != nullptr)
		*Spawnable = Parms.Spawnable;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetRandomSpawnables
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<E_Spawnable>&              Options                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<E_Spawnable>*                    Spawnables_0                                           (Parm, OutParm)

void ABP_UPGameSession_C::GetRandomSpawnables(const TArray<E_Spawnable>& Options, int32 Count, TArray<E_Spawnable>* Spawnables_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetRandomSpawnables");

	Params::BP_UPGameSession_C_GetRandomSpawnables Parms{};

	Parms.Options = std::move(Options);
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (Spawnables_0 != nullptr)
		*Spawnables_0 = std::move(Parms.Spawnables_0);
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetRandomSpawner
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class ABP_Spawner_C*>&     Spawners_0                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class ABP_Spawner_C**                   Spawner                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetRandomSpawner(const TArray<class ABP_Spawner_C*>& Spawners_0, class ABP_Spawner_C** Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetRandomSpawner");

	Params::BP_UPGameSession_C_GetRandomSpawner Parms{};

	Parms.Spawners_0 = std::move(Spawners_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Spawner != nullptr)
		*Spawner = Parms.Spawner;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetRandomTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetRandomTime(double Min, double Max, double* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetRandomTime");

	Params::BP_UPGameSession_C_GetRandomTime Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetSpawnableClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass**                          Class_0                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetSpawnableClass(E_Spawnable Spawnable, class UClass** Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetSpawnableClass");

	Params::BP_UPGameSession_C_GetSpawnableClass Parms{};

	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Class_0 != nullptr)
		*Class_0 = Parms.Class_0;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetSpawner
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SpawnContext                          SpawnContext                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_Spawner_C**                   Spawner                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetSpawner(E_SpawnContext SpawnContext, E_Spawnable Spawnable, class ABP_Spawner_C** Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetSpawner");

	Params::BP_UPGameSession_C_GetSpawner Parms{};

	Parms.SpawnContext = SpawnContext;
	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Spawner != nullptr)
		*Spawner = Parms.Spawner;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetSpawnRules
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Difficulty_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_SpawnWave>*            SpawnWaves_0                                           (Parm, OutParm)
// TArray<struct FS_RareSpawn>*            RareSpawns_0                                           (Parm, OutParm)
// TMap<E_Spawnable, struct FS_VariantsProbabilities>*Variants                                               (Parm, OutParm)

void ABP_UPGameSession_C::GetSpawnRules(int32 Difficulty_0, TArray<struct FS_SpawnWave>* SpawnWaves_0, TArray<struct FS_RareSpawn>* RareSpawns_0, TMap<E_Spawnable, struct FS_VariantsProbabilities>* Variants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetSpawnRules");

	Params::BP_UPGameSession_C_GetSpawnRules Parms{};

	Parms.Difficulty_0 = Difficulty_0;

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnWaves_0 != nullptr)
		*SpawnWaves_0 = std::move(Parms.SpawnWaves_0);

	if (RareSpawns_0 != nullptr)
		*RareSpawns_0 = std::move(Parms.RareSpawns_0);

	if (Variants != nullptr)
		*Variants = std::move(Parms.Variants);
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetVariant
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_SpawnableVariants&      Variants                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// const struct FS_VariantsProbabilities&  Probabilities                                          (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UClass**                          Class_0                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetVariant(const struct FS_SpawnableVariants& Variants, const struct FS_VariantsProbabilities& Probabilities, class UClass** Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetVariant");

	Params::BP_UPGameSession_C_GetVariant Parms{};

	Parms.Variants = std::move(Variants);
	Parms.Probabilities = std::move(Probabilities);

	UObject::ProcessEvent(Func, &Parms);

	if (Class_0 != nullptr)
		*Class_0 = Parms.Class_0;
}


// Function BP_UPGameSession.BP_UPGameSession_C.GetVariants
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   HasVariants                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_SpawnableVariants*            Variants                                               (Parm, OutParm, HasGetValueTypeHash)

void ABP_UPGameSession_C::GetVariants(E_Spawnable Spawnable, bool* HasVariants, struct FS_SpawnableVariants* Variants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "GetVariants");

	Params::BP_UPGameSession_C_GetVariants Parms{};

	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (HasVariants != nullptr)
		*HasVariants = Parms.HasVariants;

	if (Variants != nullptr)
		*Variants = std::move(Parms.Variants);
}


// Function BP_UPGameSession.BP_UPGameSession_C.HasSessionStarted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Started                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::HasSessionStarted(bool* Started)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "HasSessionStarted");

	Params::BP_UPGameSession_C_HasSessionStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Started != nullptr)
		*Started = Parms.Started;
}


// Function BP_UPGameSession.BP_UPGameSession_C.InitPlayerEvents
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::InitPlayerEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "InitPlayerEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.InitSessionWidget
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::InitSessionWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "InitSessionWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.IsReadyToStart
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsReady                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::IsReadyToStart(bool* IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "IsReadyToStart");

	Params::BP_UPGameSession_C_IsReadyToStart Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsReady != nullptr)
		*IsReady = Parms.IsReady;
}


// Function BP_UPGameSession.BP_UPGameSession_C.IsSpawnerUsable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Spawner_C*                    Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// E_SpawnContext                          SpawnContext                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsUsable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::IsSpawnerUsable(class ABP_Spawner_C* Spawner, E_SpawnContext SpawnContext, E_Spawnable Spawnable, bool* IsUsable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "IsSpawnerUsable");

	Params::BP_UPGameSession_C_IsSpawnerUsable Parms{};

	Parms.Spawner = Spawner;
	Parms.SpawnContext = SpawnContext;
	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (IsUsable != nullptr)
		*IsUsable = Parms.IsUsable;
}


// Function BP_UPGameSession.BP_UPGameSession_C.KillAllPlayers
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::KillAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "KillAllPlayers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.PlayerKilled
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_KillableCharacter_C*          KilledCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Killer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::PlayerKilled(class ABP_KillableCharacter_C* KilledCharacter, class AActor* Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "PlayerKilled");

	Params::BP_UPGameSession_C_PlayerKilled Parms{};

	Parms.KilledCharacter = KilledCharacter;
	Parms.Killer = Killer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_UPGameSession.BP_UPGameSession_C.PlayerSpawned
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_UPPlayerCharacter_C*          Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::PlayerSpawned(class ABP_UPPlayerCharacter_C* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "PlayerSpawned");

	Params::BP_UPGameSession_C_PlayerSpawned Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_UPGameSession.BP_UPGameSession_C.PrepareRareSpawns
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::PrepareRareSpawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "PrepareRareSpawns");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_UPGameSession_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.SelectRareSpawnable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<E_Spawnable, int32>&         Spawnables_0                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// E_Spawnable*                            Spawnable                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::SelectRareSpawnable(const TMap<E_Spawnable, int32>& Spawnables_0, E_Spawnable* Spawnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SelectRareSpawnable");

	Params::BP_UPGameSession_C_SelectRareSpawnable Parms{};

	Parms.Spawnables_0 = std::move(Spawnables_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Spawnable != nullptr)
		*Spawnable = Parms.Spawnable;
}


// Function BP_UPGameSession.BP_UPGameSession_C.SessionEnded (All)
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::SessionEnded__All_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SessionEnded (All)");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.SetSpawnRules
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Difficulty_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_SpawnWave>&            SpawnWaves_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_RareSpawn>&            RareSpawns_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TMap<E_Spawnable, struct FS_VariantsProbabilities>&Variants                                               (BlueprintVisible, BlueprintReadOnly, Parm)

void ABP_UPGameSession_C::SetSpawnRules(int32 Difficulty_0, TArray<struct FS_SpawnWave>& SpawnWaves_0, TArray<struct FS_RareSpawn>& RareSpawns_0, const TMap<E_Spawnable, struct FS_VariantsProbabilities>& Variants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SetSpawnRules");

	Params::BP_UPGameSession_C_SetSpawnRules Parms{};

	Parms.Difficulty_0 = Difficulty_0;
	Parms.SpawnWaves_0 = std::move(SpawnWaves_0);
	Parms.RareSpawns_0 = std::move(RareSpawns_0);
	Parms.Variants = std::move(Variants);

	UObject::ProcessEvent(Func, &Parms);

	SpawnWaves_0 = std::move(Parms.SpawnWaves_0);
	RareSpawns_0 = std::move(Parms.RareSpawns_0);
}


// Function BP_UPGameSession.BP_UPGameSession_C.ShouldSpawn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SpawnChance                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::ShouldSpawn(int32 SpawnChance, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "ShouldSpawn");

	Params::BP_UPGameSession_C_ShouldSpawn Parms{};

	Parms.SpawnChance = SpawnChance;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_UPGameSession.BP_UPGameSession_C.SpawnActor
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SpawnContext                          SpawnContext                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::SpawnActor(E_SpawnContext SpawnContext, E_Spawnable Spawnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SpawnActor");

	Params::BP_UPGameSession_C_SpawnActor Parms{};

	Parms.SpawnContext = SpawnContext;
	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_UPGameSession.BP_UPGameSession_C.SpawnNextWave
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::SpawnNextWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SpawnNextWave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.SpawnSpawnable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_Spawner_C*                    Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  VerticalOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          Actor                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::SpawnSpawnable(E_Spawnable Spawnable, class ABP_Spawner_C* Spawner, double VerticalOffset, class AActor** Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SpawnSpawnable");

	Params::BP_UPGameSession_C_SpawnSpawnable Parms{};

	Parms.Spawnable = Spawnable;
	Parms.Spawner = Spawner;
	Parms.VerticalOffset = VerticalOffset;

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;
}


// Function BP_UPGameSession.BP_UPGameSession_C.SpawnWave
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_SpawnWave&              Wave                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void ABP_UPGameSession_C::SpawnWave(const struct FS_SpawnWave& Wave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "SpawnWave");

	Params::BP_UPGameSession_C_SpawnWave Parms{};

	Parms.Wave = std::move(Wave);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_UPGameSession.BP_UPGameSession_C.StartSession
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::StartSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "StartSession");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.StartSpawning
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::StartSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "StartSpawning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.TrySpawn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SpawnContext                          Context                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          Actor                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::TrySpawn(E_SpawnContext Context, E_Spawnable Spawnable, class AActor** Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "TrySpawn");

	Params::BP_UPGameSession_C_TrySpawn Parms{};

	Parms.Context = Context;
	Parms.Spawnable = Spawnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;
}


// Function BP_UPGameSession.BP_UPGameSession_C.TrySpawnOnSpawner
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Spawnable                             Spawnable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_Spawner_C*                    Spawner                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxTries                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          Actor                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_UPGameSession_C::TrySpawnOnSpawner(E_Spawnable Spawnable, class ABP_Spawner_C* Spawner, int32 MaxTries, class AActor** Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "TrySpawnOnSpawner");

	Params::BP_UPGameSession_C_TrySpawnOnSpawner Parms{};

	Parms.Spawnable = Spawnable;
	Parms.Spawner = Spawner;
	Parms.MaxTries = MaxTries;

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;
}


// Function BP_UPGameSession.BP_UPGameSession_C.UpdateDifficulty
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::UpdateDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "UpdateDifficulty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_UPGameSession.BP_UPGameSession_C.UpdateTimeRemaining
// (BlueprintCallable, BlueprintEvent)

void ABP_UPGameSession_C::UpdateTimeRemaining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_UPGameSession_C", "UpdateTimeRemaining");

	UObject::ProcessEvent(Func, nullptr);
}

}

