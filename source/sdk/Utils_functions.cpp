#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Utils

#include "Basic.hpp"

#include "Utils_classes.hpp"
#include "Utils_parameters.hpp"


namespace SDK
{

// Function Utils.Utils_C.GetDangerForDifficulty
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Difficulty                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double*                                 Danger                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetDangerForDifficulty(int32 Difficulty, class UObject* __WorldContext, double* Danger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetDangerForDifficulty");

	Params::Utils_C_GetDangerForDifficulty Parms{};

	Parms.Difficulty = Difficulty;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Danger != nullptr)
		*Danger = Parms.Danger;
}


// Function Utils.Utils_C.SetPercentageValue
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTextBlock*                       Text                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// double                                  Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::SetPercentageValue(class UTextBlock* Text, double Value, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "SetPercentageValue");

	Params::Utils_C_SetPercentageValue Parms{};

	Parms.Text = Text;
	Parms.Value = Value;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.GetPawnNavData
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ARecastNavMesh**                  NavData                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetPawnNavData(class APawn* Pawn, class UObject* __WorldContext, class ARecastNavMesh** NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetPawnNavData");

	Params::Utils_C_GetPawnNavData Parms{};

	Parms.Pawn = Pawn;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NavData != nullptr)
		*NavData = Parms.NavData;
}


// Function Utils.Utils_C.GetControllerNavData
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                      Controller                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ARecastNavMesh**                  NavData                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetControllerNavData(class AController* Controller, class UObject* __WorldContext, class ARecastNavMesh** NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetControllerNavData");

	Params::Utils_C_GetControllerNavData Parms{};

	Parms.Controller = Controller;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NavData != nullptr)
		*NavData = Parms.NavData;
}


// Function Utils.Utils_C.ExportTextureAsJpg
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Texture                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::ExportTextureAsJpg(class UTexture2D* Texture, class UObject* __WorldContext, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "ExportTextureAsJpg");

	Params::Utils_C_ExportTextureAsJpg Parms{};

	Parms.Texture = Texture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Utils.Utils_C.ApplyHeadMorphTargets
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           HeadMesh                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FS_AvatarHeadMorphTargets& MorphTargets                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::ApplyHeadMorphTargets(class USkeletalMeshComponent* HeadMesh, const struct FS_AvatarHeadMorphTargets& MorphTargets, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "ApplyHeadMorphTargets");

	Params::Utils_C_ApplyHeadMorphTargets Parms{};

	Parms.HeadMesh = HeadMesh;
	Parms.MorphTargets = std::move(MorphTargets);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.GetCapturedActorDisplayName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FS_CameroidActorScore&     ActorScore                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          DisplayName                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UUtils_C::GetCapturedActorDisplayName(const struct FS_CameroidActorScore& ActorScore, class UObject* __WorldContext, class FString* DisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetCapturedActorDisplayName");

	Params::Utils_C_GetCapturedActorDisplayName Parms{};

	Parms.ActorScore = std::move(ActorScore);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DisplayName != nullptr)
		*DisplayName = std::move(Parms.DisplayName);
}


// Function Utils.Utils_C.IsNoBloodModeEnabled
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   NoBloodModeEnabled                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::IsNoBloodModeEnabled(class UObject* __WorldContext, bool* NoBloodModeEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "IsNoBloodModeEnabled");

	Params::Utils_C_IsNoBloodModeEnabled Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NoBloodModeEnabled != nullptr)
		*NoBloodModeEnabled = Parms.NoBloodModeEnabled;
}


// Function Utils.Utils_C.LoadAvatarMesh
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class USkeletalMeshComponent*           HeadMesh                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// const struct FS_PlayerAvatar&           Avatar                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::LoadAvatarMesh(class USkeletalMeshComponent* Mesh, class USkeletalMeshComponent* HeadMesh, const struct FS_PlayerAvatar& Avatar, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "LoadAvatarMesh");

	Params::Utils_C_LoadAvatarMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.HeadMesh = HeadMesh;
	Parms.Avatar = std::move(Avatar);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.GetInteriorVolume
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_InteriorVolume_C**            InteriorVolume                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetInteriorVolume(const struct FVector& Location, class UObject* __WorldContext, class ABP_InteriorVolume_C** InteriorVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetInteriorVolume");

	Params::Utils_C_GetInteriorVolume Parms{};

	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (InteriorVolume != nullptr)
		*InteriorVolume = Parms.InteriorVolume;
}


// Function Utils.Utils_C.InstantFear
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Initiatior                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MinFear                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::InstantFear(class AActor* Initiatior, double Radius, double MinFear, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "InstantFear");

	Params::Utils_C_InstantFear Parms{};

	Parms.Initiatior = Initiatior;
	Parms.Radius = Radius;
	Parms.MinFear = MinFear;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.IsInFrustrum
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Point                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CameraLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  CameraRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  HorizontalHalfFov                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  VerticalHalfFov                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::IsInFrustrum(const struct FVector& Point, const struct FVector& CameraLocation, const struct FRotator& CameraRotation, double HorizontalHalfFov, double VerticalHalfFov, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "IsInFrustrum");

	Params::Utils_C_IsInFrustrum Parms{};

	Parms.Point = std::move(Point);
	Parms.CameraLocation = std::move(CameraLocation);
	Parms.CameraRotation = std::move(CameraRotation);
	Parms.HorizontalHalfFov = HorizontalHalfFov;
	Parms.VerticalHalfFov = VerticalHalfFov;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Utils.Utils_C.OneShotRadialImpulse
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URadialForceComponent*            RadialForce                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::OneShotRadialImpulse(class URadialForceComponent* RadialForce, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "OneShotRadialImpulse");

	Params::Utils_C_OneShotRadialImpulse Parms{};

	Parms.RadialForce = RadialForce;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.IsSessionHost
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsHost                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::IsSessionHost(const class UObject* WorldContextObject, class UObject* __WorldContext, bool* IsHost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "IsSessionHost");

	Params::Utils_C_IsSessionHost Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsHost != nullptr)
		*IsHost = Parms.IsHost;
}


// Function Utils.Utils_C.GetInventoryItemSaveSlot
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          Slot                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UUtils_C::GetInventoryItemSaveSlot(int32 ItemId, class UObject* __WorldContext, class FString* Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetInventoryItemSaveSlot");

	Params::Utils_C_GetInventoryItemSaveSlot Parms{};

	Parms.ItemId = ItemId;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Slot != nullptr)
		*Slot = std::move(Parms.Slot);
}


// Function Utils.Utils_C.GetInventoryItemInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const class UObject*&                   Context                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// const E_InventoryItem&                  Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FS_InventoryItem*                ItemInfo                                               (Parm, OutParm, HasGetValueTypeHash)

void UUtils_C::GetInventoryItemInfo(const class UObject*& Context, const E_InventoryItem& Item, class UObject* __WorldContext, struct FS_InventoryItem* ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "GetInventoryItemInfo");

	Params::Utils_C_GetInventoryItemInfo Parms{};

	Parms.Context = Context;
	Parms.Item = Item;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ItemInfo != nullptr)
		*ItemInfo = std::move(Parms.ItemInfo);
}


// Function Utils.Utils_C.PrettifyBPClassName
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UUtils_C::PrettifyBPClassName(class UClass* Class_0, class UObject* __WorldContext, class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "PrettifyBPClassName");

	Params::Utils_C_PrettifyBPClassName Parms{};

	Parms.Class_0 = Class_0;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function Utils.Utils_C.CanShowInputWidget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanOpen                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::CanShowInputWidget(class UWidget* Widget, class UObject* __WorldContext, bool* CanOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "CanShowInputWidget");

	Params::Utils_C_CanShowInputWidget Parms{};

	Parms.Widget = Widget;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CanOpen != nullptr)
		*CanOpen = Parms.CanOpen;
}


// Function Utils.Utils_C.HideInputWidget
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::HideInputWidget(class UWidget* Widget, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "HideInputWidget");

	Params::Utils_C_HideInputWidget Parms{};

	Parms.Widget = Widget;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.ShowImmersiveWidget
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::ShowImmersiveWidget(class UWidget* Widget, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "ShowImmersiveWidget");

	Params::Utils_C_ShowImmersiveWidget Parms{};

	Parms.Widget = Widget;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.ShowInputWidget
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWidget*                          Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyUI                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::ShowInputWidget(class UWidget* Widget, bool OnlyUI, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "ShowInputWidget");

	Params::Utils_C_ShowInputWidget Parms{};

	Parms.Widget = Widget;
	Parms.OnlyUI = OnlyUI;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.IsNotEmpty
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UObject*>&                 Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsNotEmpty_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::IsNotEmpty(TArray<class UObject*>& Array, class UObject* __WorldContext, bool* IsNotEmpty_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Utils_C", "IsNotEmpty");

	Params::Utils_C_IsNotEmpty Parms{};

	Parms.Array = std::move(Array);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (IsNotEmpty_0 != nullptr)
		*IsNotEmpty_0 = Parms.IsNotEmpty_0;
}


// Function Utils.Utils_C.GetAffinity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TMap<class UClass*, bool>&        Affinities                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   Affinity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetAffinity(const TMap<class UClass*, bool>& Affinities, class AActor* Actor, class UObject* __WorldContext, bool* Affinity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "GetAffinity");

	Params::Utils_C_GetAffinity Parms{};

	Parms.Affinities = std::move(Affinities);
	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (Affinity != nullptr)
		*Affinity = Parms.Affinity;
}


// Function Utils.Utils_C.GetMaxScore
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_CameroidActorScore>&   ActorsScores                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32*                                  MaxScore                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetMaxScore(TArray<struct FS_CameroidActorScore>& ActorsScores, class UObject* __WorldContext, int32* MaxScore, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "GetMaxScore");

	Params::Utils_C_GetMaxScore Parms{};

	Parms.ActorsScores = std::move(ActorsScores);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	ActorsScores = std::move(Parms.ActorsScores);

	if (MaxScore != nullptr)
		*MaxScore = Parms.MaxScore;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function Utils.Utils_C.GetSortedActorsScores
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_CameroidCapture&        Capture                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_CameroidActorScore>*   ActorsScores                                           (Parm, OutParm)

void UUtils_C::GetSortedActorsScores(const struct FS_CameroidCapture& Capture, class UObject* __WorldContext, TArray<struct FS_CameroidActorScore>* ActorsScores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "GetSortedActorsScores");

	Params::Utils_C_GetSortedActorsScores Parms{};

	Parms.Capture = std::move(Capture);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (ActorsScores != nullptr)
		*ActorsScores = std::move(Parms.ActorsScores);
}


// Function Utils.Utils_C.GetTeleportSkinnedMeshLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkinnedMeshComponent*            Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TeleportLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::GetTeleportSkinnedMeshLocation(class USkinnedMeshComponent* Mesh, class FName BoneName, const struct FVector& Location, class UObject* __WorldContext, struct FVector* TeleportLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "GetTeleportSkinnedMeshLocation");

	Params::Utils_C_GetTeleportSkinnedMeshLocation Parms{};

	Parms.Mesh = Mesh;
	Parms.BoneName = BoneName;
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (TeleportLocation != nullptr)
		*TeleportLocation = std::move(Parms.TeleportLocation);
}


// Function Utils.Utils_C.TeleportSkinnedMesh
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkinnedMeshComponent*            Mesh                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UUtils_C::TeleportSkinnedMesh(class USkinnedMeshComponent* Mesh, class FName BoneName, const struct FVector& Location, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "TeleportSkinnedMesh");

	Params::Utils_C_TeleportSkinnedMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.BoneName = BoneName;
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Utils.Utils_C.PredictActorLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UUtils_C::PredictActorLocation(class AActor* Actor, double Time, class UObject* __WorldContext, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Utils_C", "PredictActorLocation");

	Params::Utils_C_PredictActorLocation Parms{};

	Parms.Actor = Actor;
	Parms.Time = Time;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}

}

