#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Headliners

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_classes.hpp"
#include "NavigationSystem_classes.hpp"


namespace SDK
{

// Class Headliners.HCharacter
// 0x0000 (0x0680 - 0x0680)
class AHCharacter : public ACharacter
{
public:
	class UHCharacterMovementComponent*           HCharacterMovementComponent;                       // 0x0678(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HCharacter">();
	}
	static class AHCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHCharacter>();
	}
};
static_assert(alignof(AHCharacter) == 0x000010, "Wrong alignment on AHCharacter");
static_assert(sizeof(AHCharacter) == 0x000680, "Wrong size on AHCharacter");
static_assert(offsetof(AHCharacter, HCharacterMovementComponent) == 0x000678, "Member 'AHCharacter::HCharacterMovementComponent' has a wrong offset!");

// Class Headliners.HCharacterMovementComponent
// 0x0000 (0x0F50 - 0x0F50)
class UHCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HCharacterMovementComponent">();
	}
	static class UHCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHCharacterMovementComponent>();
	}
};
static_assert(alignof(UHCharacterMovementComponent) == 0x000010, "Wrong alignment on UHCharacterMovementComponent");
static_assert(sizeof(UHCharacterMovementComponent) == 0x000F50, "Wrong size on UHCharacterMovementComponent");

// Class Headliners.HeadlinersBPUtils
// 0x0000 (0x0028 - 0x0028)
class UHeadlinersBPUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FAsyncCoroutine CompressTextureToJpgAsync(const struct FLatentActionInfo& LatentInfo, class UTexture2D* Texture, TArray<uint8>* CompressedData);
	static struct FAsyncCoroutine CreateTextureFromJPEGAsync(const struct FLatentActionInfo& LatentInfo, const TArray<uint8>& CompressedData, class UTexture2D** OutTexture);
	static class UTexture2D* CreateTextureFromRGBA(const TArray<struct FColor>& Data, int32 Width, int32 Height);
	static class UTexture2D* ExportAsTexture(class UTextureRenderTarget2D* RenderTarget);
	static struct FAsyncCoroutine ExportAsTextureAsync(const struct FLatentActionInfo& LatentInfo, class UTextureRenderTarget2D* RenderTarget, class UTexture2D** OutTexture);
	static void ForceCrash();
	static TArray<class AActor*> GetAllActorsOfClassFromLevel(class ULevel* Level, TSubclassOf<class AActor> ActorClass);
	static TArray<class FString> GetAllSaveFileNames();
	static struct FMinimalViewInfo GetCameraView(class USceneCaptureComponent2D* CaptureComponent, float DeltaTime);
	static class UObject* GetDefaultObjectOfClass(TSubclassOf<class UObject> Class_0);
	static class FString GetDesktopFolderPath();
	static bool GetFocusedWidgetGeometry(struct FGeometry* OutGeometry);
	static TArray<class UMaterialExpression*> GetMaterialExpressions(class UMaterial* Material);
	static class FString GetProjectVersion();
	static TSoftObjectPtr<class UWorld> GetSoftWorldRef(const struct FSoftObjectPath& Path);
	static class UUPGameViewportClient* GetViewportClient();
	static struct FAsyncCoroutine JPEGCompressionAsync(const struct FLatentActionInfo& LatentInfo, class UTextureRenderTarget2D* RenderTarget, TArray<uint8>* CompressedData);
	static bool ParseStringToInt64(const class FString& InString, int64* OutValue);
	static TArray<struct FVector> SampleBoundsPoints(const struct FVector& Origin, const struct FVector& Extent, float BoundsScale, int32 Resolution);
	static void SaveJPEG(const TArray<uint8>& CompressedData, const class FString& OutPath);
	static void SetMapsToCook(const TArray<class FString>& Maps);
	static void SetViewportRenderingEnabled(bool bEnable);
	static void SortIntegerArray(const TArray<int32>& InIntegerArray, TArray<int32>* OutIntegerArray);
	static void SortStringArray(const TArray<class FString>& InStringArray, TArray<class FString>* OutStringArray);
	static void UpdateCamera(class APlayerCameraManager* PlayerCameraManager, float DeltaTime);
	static class FString WrapText(const class FString& InputText, int32 MaxCharactersPerLine);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadlinersBPUtils">();
	}
	static class UHeadlinersBPUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadlinersBPUtils>();
	}
};
static_assert(alignof(UHeadlinersBPUtils) == 0x000008, "Wrong alignment on UHeadlinersBPUtils");
static_assert(sizeof(UHeadlinersBPUtils) == 0x000028, "Wrong size on UHeadlinersBPUtils");

// Class Headliners.HLocalizationUtils
// 0x0000 (0x0028 - 0x0028)
class UHLocalizationUtils final : public UBlueprintFunctionLibrary
{
public:
	static void ExportTranslationsToCSV(const class FString& LocalizationFolder, const class FString& OutputCSVPath);
	static void ImportTranslationsFromCSV(const class FString& LocalizationFolder, const class FString& CSVFilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HLocalizationUtils">();
	}
	static class UHLocalizationUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHLocalizationUtils>();
	}
};
static_assert(alignof(UHLocalizationUtils) == 0x000008, "Wrong alignment on UHLocalizationUtils");
static_assert(sizeof(UHLocalizationUtils) == 0x000028, "Wrong size on UHLocalizationUtils");

// Class Headliners.HNetworkUtil
// 0x0000 (0x0028 - 0x0028)
class UHNetworkUtil final : public UBlueprintFunctionLibrary
{
public:
	static void GetNetworkStatistics(class UObject* WorldContextObject, float* InBytesPerSecond, float* OutBytesPerSecond);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HNetworkUtil">();
	}
	static class UHNetworkUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHNetworkUtil>();
	}
};
static_assert(alignof(UHNetworkUtil) == 0x000008, "Wrong alignment on UHNetworkUtil");
static_assert(sizeof(UHNetworkUtil) == 0x000028, "Wrong size on UHNetworkUtil");

// Class Headliners.HSkeletalMeshUtil
// 0x0000 (0x0028 - 0x0028)
class UHSkeletalMeshUtil final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FBodyInstance> GetSkeletalMeshBodies(class USkeletalMeshComponent* Mesh);
	static TArray<int32> GetSkeletalMeshBodiesBoneIndices(class USkeletalMeshComponent* Mesh);
	static struct FVector GetSkeletalMeshBodyAngularVelocity(class USkeletalMeshComponent* Mesh, int32 BodyIndex);
	static struct FVector GetSkeletalMeshBodyLinearVelocity(class USkeletalMeshComponent* Mesh, int32 BodyIndex);
	static struct FTransform GetSkeletalMeshBodyTransform(class USkeletalMeshComponent* Mesh, int32 BodyIndex);
	static void RebuildSkeletalMeshSocketMap(class USkeletalMesh* Mesh);
	static void SetSkeletalMeshBodyAngularVelocity(class USkeletalMeshComponent* Mesh, int32 BodyIndex, const struct FVector& AngularVelocity);
	static void SetSkeletalMeshBodyLinearVelocity(class USkeletalMeshComponent* Mesh, int32 BodyIndex, const struct FVector& LinearVelocity);
	static void SetSkeletalMeshBodyTransform(class USkeletalMeshComponent* Mesh, int32 BodyIndex, const struct FTransform& BodyTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HSkeletalMeshUtil">();
	}
	static class UHSkeletalMeshUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHSkeletalMeshUtil>();
	}
};
static_assert(alignof(UHSkeletalMeshUtil) == 0x000008, "Wrong alignment on UHSkeletalMeshUtil");
static_assert(sizeof(UHSkeletalMeshUtil) == 0x000028, "Wrong size on UHSkeletalMeshUtil");

// Class Headliners.ModuleLevelInstance
// 0x0000 (0x0338 - 0x0338)
class AModuleLevelInstance final : public ALevelInstance
{
public:
	void SetLevelInstanceWorldAsset(TSoftObjectPtr<class UWorld> NewWorldAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModuleLevelInstance">();
	}
	static class AModuleLevelInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModuleLevelInstance>();
	}
};
static_assert(alignof(AModuleLevelInstance) == 0x000008, "Wrong alignment on AModuleLevelInstance");
static_assert(sizeof(AModuleLevelInstance) == 0x000338, "Wrong size on AModuleLevelInstance");

// Class Headliners.UPGameViewportClient
// 0x0028 (0x03D8 - 0x03B0)
class UUPGameViewportClient : public UGameViewportClient
{
public:
	uint8                                         Pad_3B0[0x28];                                     // 0x03B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddViewportWidget(class UUserWidget* Widget, int32 ZOrder);
	void RemoveViewportWidget(class UUserWidget* Widget);
	void SetViewportSize(float OriginX, float OriginY, float SizeX, float SizeY);
	struct FAsyncCoroutine TakeCapture(const struct FLatentActionInfo& LatentInfo, int32 TargetWidth, int32 TargetHeight, TArray<uint8>* CompressedImage);
	void ViewportSizeChanged(int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UPGameViewportClient">();
	}
	static class UUPGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUPGameViewportClient>();
	}
};
static_assert(alignof(UUPGameViewportClient) == 0x000008, "Wrong alignment on UUPGameViewportClient");
static_assert(sizeof(UUPGameViewportClient) == 0x0003D8, "Wrong size on UUPGameViewportClient");

// Class Headliners.UPNavLinkProxy
// 0x0000 (0x02E8 - 0x02E8)
class AUPNavLinkProxy : public ANavLinkProxy
{
public:
	void SetSmartLinkLocations(const struct FVector& RelativeStartLocation, const struct FVector& RelativeEndLocation, ENavLinkDirection Direction);
	void UpdateAreaClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UPNavLinkProxy">();
	}
	static class AUPNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUPNavLinkProxy>();
	}
};
static_assert(alignof(AUPNavLinkProxy) == 0x000008, "Wrong alignment on AUPNavLinkProxy");
static_assert(sizeof(AUPNavLinkProxy) == 0x0002E8, "Wrong size on AUPNavLinkProxy");

// Class Headliners.UPNavModifierComponent
// 0x0000 (0x0190 - 0x0190)
class UUPNavModifierComponent final : public UNavModifierComponent
{
public:
	void SetFailsafeExtent(const struct FVector& InFailsafeExtent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UPNavModifierComponent">();
	}
	static class UUPNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUPNavModifierComponent>();
	}
};
static_assert(alignof(UUPNavModifierComponent) == 0x000010, "Wrong alignment on UUPNavModifierComponent");
static_assert(sizeof(UUPNavModifierComponent) == 0x000190, "Wrong size on UUPNavModifierComponent");

}

