#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Headliners

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "UE5Coro_structs.hpp"


namespace SDK::Params
{

// Function Headliners.HeadlinersBPUtils.CompressTextureToJpgAsync
// 0x0040 (0x0040 - 0x0000)
struct HeadlinersBPUtils_CompressTextureToJpgAsync final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CompressedData;                                    // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAsyncCoroutine                        ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_CompressTextureToJpgAsync) == 0x000008, "Wrong alignment on HeadlinersBPUtils_CompressTextureToJpgAsync");
static_assert(sizeof(HeadlinersBPUtils_CompressTextureToJpgAsync) == 0x000040, "Wrong size on HeadlinersBPUtils_CompressTextureToJpgAsync");
static_assert(offsetof(HeadlinersBPUtils_CompressTextureToJpgAsync, LatentInfo) == 0x000000, "Member 'HeadlinersBPUtils_CompressTextureToJpgAsync::LatentInfo' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CompressTextureToJpgAsync, Texture) == 0x000018, "Member 'HeadlinersBPUtils_CompressTextureToJpgAsync::Texture' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CompressTextureToJpgAsync, CompressedData) == 0x000020, "Member 'HeadlinersBPUtils_CompressTextureToJpgAsync::CompressedData' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CompressTextureToJpgAsync, ReturnValue) == 0x000030, "Member 'HeadlinersBPUtils_CompressTextureToJpgAsync::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.CreateTextureFromJPEGAsync
// 0x0040 (0x0040 - 0x0000)
struct HeadlinersBPUtils_CreateTextureFromJPEGAsync final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CompressedData;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             OutTexture;                                        // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAsyncCoroutine                        ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_CreateTextureFromJPEGAsync) == 0x000008, "Wrong alignment on HeadlinersBPUtils_CreateTextureFromJPEGAsync");
static_assert(sizeof(HeadlinersBPUtils_CreateTextureFromJPEGAsync) == 0x000040, "Wrong size on HeadlinersBPUtils_CreateTextureFromJPEGAsync");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromJPEGAsync, LatentInfo) == 0x000000, "Member 'HeadlinersBPUtils_CreateTextureFromJPEGAsync::LatentInfo' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromJPEGAsync, CompressedData) == 0x000018, "Member 'HeadlinersBPUtils_CreateTextureFromJPEGAsync::CompressedData' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromJPEGAsync, OutTexture) == 0x000028, "Member 'HeadlinersBPUtils_CreateTextureFromJPEGAsync::OutTexture' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromJPEGAsync, ReturnValue) == 0x000030, "Member 'HeadlinersBPUtils_CreateTextureFromJPEGAsync::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.CreateTextureFromRGBA
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_CreateTextureFromRGBA final
{
public:
	TArray<struct FColor>                         Data;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_CreateTextureFromRGBA) == 0x000008, "Wrong alignment on HeadlinersBPUtils_CreateTextureFromRGBA");
static_assert(sizeof(HeadlinersBPUtils_CreateTextureFromRGBA) == 0x000020, "Wrong size on HeadlinersBPUtils_CreateTextureFromRGBA");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromRGBA, Data) == 0x000000, "Member 'HeadlinersBPUtils_CreateTextureFromRGBA::Data' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromRGBA, Width) == 0x000010, "Member 'HeadlinersBPUtils_CreateTextureFromRGBA::Width' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromRGBA, Height) == 0x000014, "Member 'HeadlinersBPUtils_CreateTextureFromRGBA::Height' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_CreateTextureFromRGBA, ReturnValue) == 0x000018, "Member 'HeadlinersBPUtils_CreateTextureFromRGBA::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.ExportAsTexture
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_ExportAsTexture final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_ExportAsTexture) == 0x000008, "Wrong alignment on HeadlinersBPUtils_ExportAsTexture");
static_assert(sizeof(HeadlinersBPUtils_ExportAsTexture) == 0x000010, "Wrong size on HeadlinersBPUtils_ExportAsTexture");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTexture, RenderTarget) == 0x000000, "Member 'HeadlinersBPUtils_ExportAsTexture::RenderTarget' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTexture, ReturnValue) == 0x000008, "Member 'HeadlinersBPUtils_ExportAsTexture::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.ExportAsTextureAsync
// 0x0038 (0x0038 - 0x0000)
struct HeadlinersBPUtils_ExportAsTextureAsync final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OutTexture;                                        // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAsyncCoroutine                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_ExportAsTextureAsync) == 0x000008, "Wrong alignment on HeadlinersBPUtils_ExportAsTextureAsync");
static_assert(sizeof(HeadlinersBPUtils_ExportAsTextureAsync) == 0x000038, "Wrong size on HeadlinersBPUtils_ExportAsTextureAsync");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTextureAsync, LatentInfo) == 0x000000, "Member 'HeadlinersBPUtils_ExportAsTextureAsync::LatentInfo' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTextureAsync, RenderTarget) == 0x000018, "Member 'HeadlinersBPUtils_ExportAsTextureAsync::RenderTarget' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTextureAsync, OutTexture) == 0x000020, "Member 'HeadlinersBPUtils_ExportAsTextureAsync::OutTexture' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ExportAsTextureAsync, ReturnValue) == 0x000028, "Member 'HeadlinersBPUtils_ExportAsTextureAsync::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetAllActorsOfClassFromLevel
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_GetAllActorsOfClassFromLevel final
{
public:
	class ULevel*                                 Level;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetAllActorsOfClassFromLevel) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetAllActorsOfClassFromLevel");
static_assert(sizeof(HeadlinersBPUtils_GetAllActorsOfClassFromLevel) == 0x000020, "Wrong size on HeadlinersBPUtils_GetAllActorsOfClassFromLevel");
static_assert(offsetof(HeadlinersBPUtils_GetAllActorsOfClassFromLevel, Level) == 0x000000, "Member 'HeadlinersBPUtils_GetAllActorsOfClassFromLevel::Level' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetAllActorsOfClassFromLevel, ActorClass) == 0x000008, "Member 'HeadlinersBPUtils_GetAllActorsOfClassFromLevel::ActorClass' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetAllActorsOfClassFromLevel, ReturnValue) == 0x000010, "Member 'HeadlinersBPUtils_GetAllActorsOfClassFromLevel::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetAllSaveFileNames
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_GetAllSaveFileNames final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetAllSaveFileNames) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetAllSaveFileNames");
static_assert(sizeof(HeadlinersBPUtils_GetAllSaveFileNames) == 0x000010, "Wrong size on HeadlinersBPUtils_GetAllSaveFileNames");
static_assert(offsetof(HeadlinersBPUtils_GetAllSaveFileNames, ReturnValue) == 0x000000, "Member 'HeadlinersBPUtils_GetAllSaveFileNames::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetCameraView
// 0x07D0 (0x07D0 - 0x0000)
struct HeadlinersBPUtils_GetCameraView final
{
public:
	class USceneCaptureComponent2D*               CaptureComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       ReturnValue;                                       // 0x0010(0x07C0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetCameraView) == 0x000010, "Wrong alignment on HeadlinersBPUtils_GetCameraView");
static_assert(sizeof(HeadlinersBPUtils_GetCameraView) == 0x0007D0, "Wrong size on HeadlinersBPUtils_GetCameraView");
static_assert(offsetof(HeadlinersBPUtils_GetCameraView, CaptureComponent) == 0x000000, "Member 'HeadlinersBPUtils_GetCameraView::CaptureComponent' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetCameraView, DeltaTime) == 0x000008, "Member 'HeadlinersBPUtils_GetCameraView::DeltaTime' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetCameraView, ReturnValue) == 0x000010, "Member 'HeadlinersBPUtils_GetCameraView::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetDefaultObjectOfClass
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_GetDefaultObjectOfClass final
{
public:
	TSubclassOf<class UObject>                    Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetDefaultObjectOfClass) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetDefaultObjectOfClass");
static_assert(sizeof(HeadlinersBPUtils_GetDefaultObjectOfClass) == 0x000010, "Wrong size on HeadlinersBPUtils_GetDefaultObjectOfClass");
static_assert(offsetof(HeadlinersBPUtils_GetDefaultObjectOfClass, Class_0) == 0x000000, "Member 'HeadlinersBPUtils_GetDefaultObjectOfClass::Class_0' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetDefaultObjectOfClass, ReturnValue) == 0x000008, "Member 'HeadlinersBPUtils_GetDefaultObjectOfClass::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetDesktopFolderPath
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_GetDesktopFolderPath final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetDesktopFolderPath) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetDesktopFolderPath");
static_assert(sizeof(HeadlinersBPUtils_GetDesktopFolderPath) == 0x000010, "Wrong size on HeadlinersBPUtils_GetDesktopFolderPath");
static_assert(offsetof(HeadlinersBPUtils_GetDesktopFolderPath, ReturnValue) == 0x000000, "Member 'HeadlinersBPUtils_GetDesktopFolderPath::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetFocusedWidgetGeometry
// 0x003C (0x003C - 0x0000)
struct HeadlinersBPUtils_GetFocusedWidgetGeometry final
{
public:
	struct FGeometry                              OutGeometry;                                       // 0x0000(0x0038)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeadlinersBPUtils_GetFocusedWidgetGeometry) == 0x000004, "Wrong alignment on HeadlinersBPUtils_GetFocusedWidgetGeometry");
static_assert(sizeof(HeadlinersBPUtils_GetFocusedWidgetGeometry) == 0x00003C, "Wrong size on HeadlinersBPUtils_GetFocusedWidgetGeometry");
static_assert(offsetof(HeadlinersBPUtils_GetFocusedWidgetGeometry, OutGeometry) == 0x000000, "Member 'HeadlinersBPUtils_GetFocusedWidgetGeometry::OutGeometry' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetFocusedWidgetGeometry, ReturnValue) == 0x000038, "Member 'HeadlinersBPUtils_GetFocusedWidgetGeometry::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetMaterialExpressions
// 0x0018 (0x0018 - 0x0000)
struct HeadlinersBPUtils_GetMaterialExpressions final
{
public:
	class UMaterial*                              Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialExpression*>            ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetMaterialExpressions) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetMaterialExpressions");
static_assert(sizeof(HeadlinersBPUtils_GetMaterialExpressions) == 0x000018, "Wrong size on HeadlinersBPUtils_GetMaterialExpressions");
static_assert(offsetof(HeadlinersBPUtils_GetMaterialExpressions, Material) == 0x000000, "Member 'HeadlinersBPUtils_GetMaterialExpressions::Material' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetMaterialExpressions, ReturnValue) == 0x000008, "Member 'HeadlinersBPUtils_GetMaterialExpressions::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetProjectVersion
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_GetProjectVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetProjectVersion) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetProjectVersion");
static_assert(sizeof(HeadlinersBPUtils_GetProjectVersion) == 0x000010, "Wrong size on HeadlinersBPUtils_GetProjectVersion");
static_assert(offsetof(HeadlinersBPUtils_GetProjectVersion, ReturnValue) == 0x000000, "Member 'HeadlinersBPUtils_GetProjectVersion::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetSoftWorldRef
// 0x0048 (0x0048 - 0x0000)
struct HeadlinersBPUtils_GetSoftWorldRef final
{
public:
	struct FSoftObjectPath                        Path;                                              // 0x0000(0x0020)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetSoftWorldRef) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetSoftWorldRef");
static_assert(sizeof(HeadlinersBPUtils_GetSoftWorldRef) == 0x000048, "Wrong size on HeadlinersBPUtils_GetSoftWorldRef");
static_assert(offsetof(HeadlinersBPUtils_GetSoftWorldRef, Path) == 0x000000, "Member 'HeadlinersBPUtils_GetSoftWorldRef::Path' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_GetSoftWorldRef, ReturnValue) == 0x000020, "Member 'HeadlinersBPUtils_GetSoftWorldRef::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.GetViewportClient
// 0x0008 (0x0008 - 0x0000)
struct HeadlinersBPUtils_GetViewportClient final
{
public:
	class UUPGameViewportClient*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_GetViewportClient) == 0x000008, "Wrong alignment on HeadlinersBPUtils_GetViewportClient");
static_assert(sizeof(HeadlinersBPUtils_GetViewportClient) == 0x000008, "Wrong size on HeadlinersBPUtils_GetViewportClient");
static_assert(offsetof(HeadlinersBPUtils_GetViewportClient, ReturnValue) == 0x000000, "Member 'HeadlinersBPUtils_GetViewportClient::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.JPEGCompressionAsync
// 0x0040 (0x0040 - 0x0000)
struct HeadlinersBPUtils_JPEGCompressionAsync final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CompressedData;                                    // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAsyncCoroutine                        ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_JPEGCompressionAsync) == 0x000008, "Wrong alignment on HeadlinersBPUtils_JPEGCompressionAsync");
static_assert(sizeof(HeadlinersBPUtils_JPEGCompressionAsync) == 0x000040, "Wrong size on HeadlinersBPUtils_JPEGCompressionAsync");
static_assert(offsetof(HeadlinersBPUtils_JPEGCompressionAsync, LatentInfo) == 0x000000, "Member 'HeadlinersBPUtils_JPEGCompressionAsync::LatentInfo' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_JPEGCompressionAsync, RenderTarget) == 0x000018, "Member 'HeadlinersBPUtils_JPEGCompressionAsync::RenderTarget' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_JPEGCompressionAsync, CompressedData) == 0x000020, "Member 'HeadlinersBPUtils_JPEGCompressionAsync::CompressedData' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_JPEGCompressionAsync, ReturnValue) == 0x000030, "Member 'HeadlinersBPUtils_JPEGCompressionAsync::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.ParseStringToInt64
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_ParseStringToInt64 final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OutValue;                                          // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeadlinersBPUtils_ParseStringToInt64) == 0x000008, "Wrong alignment on HeadlinersBPUtils_ParseStringToInt64");
static_assert(sizeof(HeadlinersBPUtils_ParseStringToInt64) == 0x000020, "Wrong size on HeadlinersBPUtils_ParseStringToInt64");
static_assert(offsetof(HeadlinersBPUtils_ParseStringToInt64, InString) == 0x000000, "Member 'HeadlinersBPUtils_ParseStringToInt64::InString' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ParseStringToInt64, OutValue) == 0x000010, "Member 'HeadlinersBPUtils_ParseStringToInt64::OutValue' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_ParseStringToInt64, ReturnValue) == 0x000018, "Member 'HeadlinersBPUtils_ParseStringToInt64::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SampleBoundsPoints
// 0x0048 (0x0048 - 0x0000)
struct HeadlinersBPUtils_SampleBoundsPoints final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundsScale;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Resolution;                                        // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SampleBoundsPoints) == 0x000008, "Wrong alignment on HeadlinersBPUtils_SampleBoundsPoints");
static_assert(sizeof(HeadlinersBPUtils_SampleBoundsPoints) == 0x000048, "Wrong size on HeadlinersBPUtils_SampleBoundsPoints");
static_assert(offsetof(HeadlinersBPUtils_SampleBoundsPoints, Origin) == 0x000000, "Member 'HeadlinersBPUtils_SampleBoundsPoints::Origin' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SampleBoundsPoints, Extent) == 0x000018, "Member 'HeadlinersBPUtils_SampleBoundsPoints::Extent' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SampleBoundsPoints, BoundsScale) == 0x000030, "Member 'HeadlinersBPUtils_SampleBoundsPoints::BoundsScale' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SampleBoundsPoints, Resolution) == 0x000034, "Member 'HeadlinersBPUtils_SampleBoundsPoints::Resolution' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SampleBoundsPoints, ReturnValue) == 0x000038, "Member 'HeadlinersBPUtils_SampleBoundsPoints::ReturnValue' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SaveJPEG
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_SaveJPEG final
{
public:
	TArray<uint8>                                 CompressedData;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 OutPath;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SaveJPEG) == 0x000008, "Wrong alignment on HeadlinersBPUtils_SaveJPEG");
static_assert(sizeof(HeadlinersBPUtils_SaveJPEG) == 0x000020, "Wrong size on HeadlinersBPUtils_SaveJPEG");
static_assert(offsetof(HeadlinersBPUtils_SaveJPEG, CompressedData) == 0x000000, "Member 'HeadlinersBPUtils_SaveJPEG::CompressedData' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SaveJPEG, OutPath) == 0x000010, "Member 'HeadlinersBPUtils_SaveJPEG::OutPath' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SetMapsToCook
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_SetMapsToCook final
{
public:
	TArray<class FString>                         Maps;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SetMapsToCook) == 0x000008, "Wrong alignment on HeadlinersBPUtils_SetMapsToCook");
static_assert(sizeof(HeadlinersBPUtils_SetMapsToCook) == 0x000010, "Wrong size on HeadlinersBPUtils_SetMapsToCook");
static_assert(offsetof(HeadlinersBPUtils_SetMapsToCook, Maps) == 0x000000, "Member 'HeadlinersBPUtils_SetMapsToCook::Maps' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SetViewportRenderingEnabled
// 0x0001 (0x0001 - 0x0000)
struct HeadlinersBPUtils_SetViewportRenderingEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SetViewportRenderingEnabled) == 0x000001, "Wrong alignment on HeadlinersBPUtils_SetViewportRenderingEnabled");
static_assert(sizeof(HeadlinersBPUtils_SetViewportRenderingEnabled) == 0x000001, "Wrong size on HeadlinersBPUtils_SetViewportRenderingEnabled");
static_assert(offsetof(HeadlinersBPUtils_SetViewportRenderingEnabled, bEnable) == 0x000000, "Member 'HeadlinersBPUtils_SetViewportRenderingEnabled::bEnable' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SortIntegerArray
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_SortIntegerArray final
{
public:
	TArray<int32>                                 InIntegerArray;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 OutIntegerArray;                                   // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SortIntegerArray) == 0x000008, "Wrong alignment on HeadlinersBPUtils_SortIntegerArray");
static_assert(sizeof(HeadlinersBPUtils_SortIntegerArray) == 0x000020, "Wrong size on HeadlinersBPUtils_SortIntegerArray");
static_assert(offsetof(HeadlinersBPUtils_SortIntegerArray, InIntegerArray) == 0x000000, "Member 'HeadlinersBPUtils_SortIntegerArray::InIntegerArray' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SortIntegerArray, OutIntegerArray) == 0x000010, "Member 'HeadlinersBPUtils_SortIntegerArray::OutIntegerArray' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.SortStringArray
// 0x0020 (0x0020 - 0x0000)
struct HeadlinersBPUtils_SortStringArray final
{
public:
	TArray<class FString>                         InStringArray;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutStringArray;                                    // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_SortStringArray) == 0x000008, "Wrong alignment on HeadlinersBPUtils_SortStringArray");
static_assert(sizeof(HeadlinersBPUtils_SortStringArray) == 0x000020, "Wrong size on HeadlinersBPUtils_SortStringArray");
static_assert(offsetof(HeadlinersBPUtils_SortStringArray, InStringArray) == 0x000000, "Member 'HeadlinersBPUtils_SortStringArray::InStringArray' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_SortStringArray, OutStringArray) == 0x000010, "Member 'HeadlinersBPUtils_SortStringArray::OutStringArray' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.UpdateCamera
// 0x0010 (0x0010 - 0x0000)
struct HeadlinersBPUtils_UpdateCamera final
{
public:
	class APlayerCameraManager*                   PlayerCameraManager;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HeadlinersBPUtils_UpdateCamera) == 0x000008, "Wrong alignment on HeadlinersBPUtils_UpdateCamera");
static_assert(sizeof(HeadlinersBPUtils_UpdateCamera) == 0x000010, "Wrong size on HeadlinersBPUtils_UpdateCamera");
static_assert(offsetof(HeadlinersBPUtils_UpdateCamera, PlayerCameraManager) == 0x000000, "Member 'HeadlinersBPUtils_UpdateCamera::PlayerCameraManager' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_UpdateCamera, DeltaTime) == 0x000008, "Member 'HeadlinersBPUtils_UpdateCamera::DeltaTime' has a wrong offset!");

// Function Headliners.HeadlinersBPUtils.WrapText
// 0x0028 (0x0028 - 0x0000)
struct HeadlinersBPUtils_WrapText final
{
public:
	class FString                                 InputText;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCharactersPerLine;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HeadlinersBPUtils_WrapText) == 0x000008, "Wrong alignment on HeadlinersBPUtils_WrapText");
static_assert(sizeof(HeadlinersBPUtils_WrapText) == 0x000028, "Wrong size on HeadlinersBPUtils_WrapText");
static_assert(offsetof(HeadlinersBPUtils_WrapText, InputText) == 0x000000, "Member 'HeadlinersBPUtils_WrapText::InputText' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_WrapText, MaxCharactersPerLine) == 0x000010, "Member 'HeadlinersBPUtils_WrapText::MaxCharactersPerLine' has a wrong offset!");
static_assert(offsetof(HeadlinersBPUtils_WrapText, ReturnValue) == 0x000018, "Member 'HeadlinersBPUtils_WrapText::ReturnValue' has a wrong offset!");

// Function Headliners.HLocalizationUtils.ExportTranslationsToCSV
// 0x0020 (0x0020 - 0x0000)
struct HLocalizationUtils_ExportTranslationsToCSV final
{
public:
	class FString                                 LocalizationFolder;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutputCSVPath;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HLocalizationUtils_ExportTranslationsToCSV) == 0x000008, "Wrong alignment on HLocalizationUtils_ExportTranslationsToCSV");
static_assert(sizeof(HLocalizationUtils_ExportTranslationsToCSV) == 0x000020, "Wrong size on HLocalizationUtils_ExportTranslationsToCSV");
static_assert(offsetof(HLocalizationUtils_ExportTranslationsToCSV, LocalizationFolder) == 0x000000, "Member 'HLocalizationUtils_ExportTranslationsToCSV::LocalizationFolder' has a wrong offset!");
static_assert(offsetof(HLocalizationUtils_ExportTranslationsToCSV, OutputCSVPath) == 0x000010, "Member 'HLocalizationUtils_ExportTranslationsToCSV::OutputCSVPath' has a wrong offset!");

// Function Headliners.HLocalizationUtils.ImportTranslationsFromCSV
// 0x0020 (0x0020 - 0x0000)
struct HLocalizationUtils_ImportTranslationsFromCSV final
{
public:
	class FString                                 LocalizationFolder;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CSVFilePath;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HLocalizationUtils_ImportTranslationsFromCSV) == 0x000008, "Wrong alignment on HLocalizationUtils_ImportTranslationsFromCSV");
static_assert(sizeof(HLocalizationUtils_ImportTranslationsFromCSV) == 0x000020, "Wrong size on HLocalizationUtils_ImportTranslationsFromCSV");
static_assert(offsetof(HLocalizationUtils_ImportTranslationsFromCSV, LocalizationFolder) == 0x000000, "Member 'HLocalizationUtils_ImportTranslationsFromCSV::LocalizationFolder' has a wrong offset!");
static_assert(offsetof(HLocalizationUtils_ImportTranslationsFromCSV, CSVFilePath) == 0x000010, "Member 'HLocalizationUtils_ImportTranslationsFromCSV::CSVFilePath' has a wrong offset!");

// Function Headliners.HNetworkUtil.GetNetworkStatistics
// 0x0010 (0x0010 - 0x0000)
struct HNetworkUtil_GetNetworkStatistics final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBytesPerSecond;                                  // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutBytesPerSecond;                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HNetworkUtil_GetNetworkStatistics) == 0x000008, "Wrong alignment on HNetworkUtil_GetNetworkStatistics");
static_assert(sizeof(HNetworkUtil_GetNetworkStatistics) == 0x000010, "Wrong size on HNetworkUtil_GetNetworkStatistics");
static_assert(offsetof(HNetworkUtil_GetNetworkStatistics, WorldContextObject) == 0x000000, "Member 'HNetworkUtil_GetNetworkStatistics::WorldContextObject' has a wrong offset!");
static_assert(offsetof(HNetworkUtil_GetNetworkStatistics, InBytesPerSecond) == 0x000008, "Member 'HNetworkUtil_GetNetworkStatistics::InBytesPerSecond' has a wrong offset!");
static_assert(offsetof(HNetworkUtil_GetNetworkStatistics, OutBytesPerSecond) == 0x00000C, "Member 'HNetworkUtil_GetNetworkStatistics::OutBytesPerSecond' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.GetSkeletalMeshBodies
// 0x0018 (0x0018 - 0x0000)
struct HSkeletalMeshUtil_GetSkeletalMeshBodies final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBodyInstance>                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_GetSkeletalMeshBodies) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_GetSkeletalMeshBodies");
static_assert(sizeof(HSkeletalMeshUtil_GetSkeletalMeshBodies) == 0x000018, "Wrong size on HSkeletalMeshUtil_GetSkeletalMeshBodies");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodies, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodies::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodies, ReturnValue) == 0x000008, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodies::ReturnValue' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.GetSkeletalMeshBodiesBoneIndices
// 0x0018 (0x0018 - 0x0000)
struct HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices");
static_assert(sizeof(HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices) == 0x000018, "Wrong size on HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices, ReturnValue) == 0x000008, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodiesBoneIndices::ReturnValue' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.GetSkeletalMeshBodyAngularVelocity
// 0x0028 (0x0028 - 0x0000)
struct HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity");
static_assert(sizeof(HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity) == 0x000028, "Wrong size on HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity, ReturnValue) == 0x000010, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyAngularVelocity::ReturnValue' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.GetSkeletalMeshBodyLinearVelocity
// 0x0028 (0x0028 - 0x0000)
struct HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity");
static_assert(sizeof(HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity) == 0x000028, "Wrong size on HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity, ReturnValue) == 0x000010, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyLinearVelocity::ReturnValue' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.GetSkeletalMeshBodyTransform
// 0x0070 (0x0070 - 0x0000)
struct HSkeletalMeshUtil_GetSkeletalMeshBodyTransform final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_GetSkeletalMeshBodyTransform) == 0x000010, "Wrong alignment on HSkeletalMeshUtil_GetSkeletalMeshBodyTransform");
static_assert(sizeof(HSkeletalMeshUtil_GetSkeletalMeshBodyTransform) == 0x000070, "Wrong size on HSkeletalMeshUtil_GetSkeletalMeshBodyTransform");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyTransform, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyTransform::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyTransform, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyTransform::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_GetSkeletalMeshBodyTransform, ReturnValue) == 0x000010, "Member 'HSkeletalMeshUtil_GetSkeletalMeshBodyTransform::ReturnValue' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.RebuildSkeletalMeshSocketMap
// 0x0008 (0x0008 - 0x0000)
struct HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap");
static_assert(sizeof(HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap) == 0x000008, "Wrong size on HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap");
static_assert(offsetof(HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_RebuildSkeletalMeshSocketMap::Mesh' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.SetSkeletalMeshBodyAngularVelocity
// 0x0028 (0x0028 - 0x0000)
struct HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AngularVelocity;                                   // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity");
static_assert(sizeof(HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity) == 0x000028, "Wrong size on HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity, AngularVelocity) == 0x000010, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyAngularVelocity::AngularVelocity' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.SetSkeletalMeshBodyLinearVelocity
// 0x0028 (0x0028 - 0x0000)
struct HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LinearVelocity;                                    // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity) == 0x000008, "Wrong alignment on HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity");
static_assert(sizeof(HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity) == 0x000028, "Wrong size on HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity, LinearVelocity) == 0x000010, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyLinearVelocity::LinearVelocity' has a wrong offset!");

// Function Headliners.HSkeletalMeshUtil.SetSkeletalMeshBodyTransform
// 0x0070 (0x0070 - 0x0000)
struct HSkeletalMeshUtil_SetSkeletalMeshBodyTransform final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BodyIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BodyTransform;                                     // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HSkeletalMeshUtil_SetSkeletalMeshBodyTransform) == 0x000010, "Wrong alignment on HSkeletalMeshUtil_SetSkeletalMeshBodyTransform");
static_assert(sizeof(HSkeletalMeshUtil_SetSkeletalMeshBodyTransform) == 0x000070, "Wrong size on HSkeletalMeshUtil_SetSkeletalMeshBodyTransform");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyTransform, Mesh) == 0x000000, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyTransform::Mesh' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyTransform, BodyIndex) == 0x000008, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyTransform::BodyIndex' has a wrong offset!");
static_assert(offsetof(HSkeletalMeshUtil_SetSkeletalMeshBodyTransform, BodyTransform) == 0x000010, "Member 'HSkeletalMeshUtil_SetSkeletalMeshBodyTransform::BodyTransform' has a wrong offset!");

// Function Headliners.ModuleLevelInstance.SetLevelInstanceWorldAsset
// 0x0028 (0x0028 - 0x0000)
struct ModuleLevelInstance_SetLevelInstanceWorldAsset final
{
public:
	TSoftObjectPtr<class UWorld>                  NewWorldAsset;                                     // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ModuleLevelInstance_SetLevelInstanceWorldAsset) == 0x000008, "Wrong alignment on ModuleLevelInstance_SetLevelInstanceWorldAsset");
static_assert(sizeof(ModuleLevelInstance_SetLevelInstanceWorldAsset) == 0x000028, "Wrong size on ModuleLevelInstance_SetLevelInstanceWorldAsset");
static_assert(offsetof(ModuleLevelInstance_SetLevelInstanceWorldAsset, NewWorldAsset) == 0x000000, "Member 'ModuleLevelInstance_SetLevelInstanceWorldAsset::NewWorldAsset' has a wrong offset!");

// Function Headliners.UPGameViewportClient.AddViewportWidget
// 0x0010 (0x0010 - 0x0000)
struct UPGameViewportClient_AddViewportWidget final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UPGameViewportClient_AddViewportWidget) == 0x000008, "Wrong alignment on UPGameViewportClient_AddViewportWidget");
static_assert(sizeof(UPGameViewportClient_AddViewportWidget) == 0x000010, "Wrong size on UPGameViewportClient_AddViewportWidget");
static_assert(offsetof(UPGameViewportClient_AddViewportWidget, Widget) == 0x000000, "Member 'UPGameViewportClient_AddViewportWidget::Widget' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_AddViewportWidget, ZOrder) == 0x000008, "Member 'UPGameViewportClient_AddViewportWidget::ZOrder' has a wrong offset!");

// Function Headliners.UPGameViewportClient.RemoveViewportWidget
// 0x0008 (0x0008 - 0x0000)
struct UPGameViewportClient_RemoveViewportWidget final
{
public:
	class UUserWidget*                            Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UPGameViewportClient_RemoveViewportWidget) == 0x000008, "Wrong alignment on UPGameViewportClient_RemoveViewportWidget");
static_assert(sizeof(UPGameViewportClient_RemoveViewportWidget) == 0x000008, "Wrong size on UPGameViewportClient_RemoveViewportWidget");
static_assert(offsetof(UPGameViewportClient_RemoveViewportWidget, Widget) == 0x000000, "Member 'UPGameViewportClient_RemoveViewportWidget::Widget' has a wrong offset!");

// Function Headliners.UPGameViewportClient.SetViewportSize
// 0x0010 (0x0010 - 0x0000)
struct UPGameViewportClient_SetViewportSize final
{
public:
	float                                         OriginX;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginY;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeX;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeY;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UPGameViewportClient_SetViewportSize) == 0x000004, "Wrong alignment on UPGameViewportClient_SetViewportSize");
static_assert(sizeof(UPGameViewportClient_SetViewportSize) == 0x000010, "Wrong size on UPGameViewportClient_SetViewportSize");
static_assert(offsetof(UPGameViewportClient_SetViewportSize, OriginX) == 0x000000, "Member 'UPGameViewportClient_SetViewportSize::OriginX' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_SetViewportSize, OriginY) == 0x000004, "Member 'UPGameViewportClient_SetViewportSize::OriginY' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_SetViewportSize, SizeX) == 0x000008, "Member 'UPGameViewportClient_SetViewportSize::SizeX' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_SetViewportSize, SizeY) == 0x00000C, "Member 'UPGameViewportClient_SetViewportSize::SizeY' has a wrong offset!");

// Function Headliners.UPGameViewportClient.TakeCapture
// 0x0040 (0x0040 - 0x0000)
struct UPGameViewportClient_TakeCapture final
{
public:
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetWidth;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetHeight;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CompressedImage;                                   // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAsyncCoroutine                        ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UPGameViewportClient_TakeCapture) == 0x000008, "Wrong alignment on UPGameViewportClient_TakeCapture");
static_assert(sizeof(UPGameViewportClient_TakeCapture) == 0x000040, "Wrong size on UPGameViewportClient_TakeCapture");
static_assert(offsetof(UPGameViewportClient_TakeCapture, LatentInfo) == 0x000000, "Member 'UPGameViewportClient_TakeCapture::LatentInfo' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_TakeCapture, TargetWidth) == 0x000018, "Member 'UPGameViewportClient_TakeCapture::TargetWidth' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_TakeCapture, TargetHeight) == 0x00001C, "Member 'UPGameViewportClient_TakeCapture::TargetHeight' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_TakeCapture, CompressedImage) == 0x000020, "Member 'UPGameViewportClient_TakeCapture::CompressedImage' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_TakeCapture, ReturnValue) == 0x000030, "Member 'UPGameViewportClient_TakeCapture::ReturnValue' has a wrong offset!");

// Function Headliners.UPGameViewportClient.ViewportSizeChanged
// 0x0008 (0x0008 - 0x0000)
struct UPGameViewportClient_ViewportSizeChanged final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UPGameViewportClient_ViewportSizeChanged) == 0x000004, "Wrong alignment on UPGameViewportClient_ViewportSizeChanged");
static_assert(sizeof(UPGameViewportClient_ViewportSizeChanged) == 0x000008, "Wrong size on UPGameViewportClient_ViewportSizeChanged");
static_assert(offsetof(UPGameViewportClient_ViewportSizeChanged, Width) == 0x000000, "Member 'UPGameViewportClient_ViewportSizeChanged::Width' has a wrong offset!");
static_assert(offsetof(UPGameViewportClient_ViewportSizeChanged, Height) == 0x000004, "Member 'UPGameViewportClient_ViewportSizeChanged::Height' has a wrong offset!");

// Function Headliners.UPNavLinkProxy.SetSmartLinkLocations
// 0x0038 (0x0038 - 0x0000)
struct UPNavLinkProxy_SetSmartLinkLocations final
{
public:
	struct FVector                                RelativeStartLocation;                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeEndLocation;                               // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             Direction;                                         // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(UPNavLinkProxy_SetSmartLinkLocations) == 0x000008, "Wrong alignment on UPNavLinkProxy_SetSmartLinkLocations");
static_assert(sizeof(UPNavLinkProxy_SetSmartLinkLocations) == 0x000038, "Wrong size on UPNavLinkProxy_SetSmartLinkLocations");
static_assert(offsetof(UPNavLinkProxy_SetSmartLinkLocations, RelativeStartLocation) == 0x000000, "Member 'UPNavLinkProxy_SetSmartLinkLocations::RelativeStartLocation' has a wrong offset!");
static_assert(offsetof(UPNavLinkProxy_SetSmartLinkLocations, RelativeEndLocation) == 0x000018, "Member 'UPNavLinkProxy_SetSmartLinkLocations::RelativeEndLocation' has a wrong offset!");
static_assert(offsetof(UPNavLinkProxy_SetSmartLinkLocations, Direction) == 0x000030, "Member 'UPNavLinkProxy_SetSmartLinkLocations::Direction' has a wrong offset!");

// Function Headliners.UPNavModifierComponent.SetFailsafeExtent
// 0x0018 (0x0018 - 0x0000)
struct UPNavModifierComponent_SetFailsafeExtent final
{
public:
	struct FVector                                InFailsafeExtent;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(UPNavModifierComponent_SetFailsafeExtent) == 0x000008, "Wrong alignment on UPNavModifierComponent_SetFailsafeExtent");
static_assert(sizeof(UPNavModifierComponent_SetFailsafeExtent) == 0x000018, "Wrong size on UPNavModifierComponent_SetFailsafeExtent");
static_assert(offsetof(UPNavModifierComponent_SetFailsafeExtent, InFailsafeExtent) == 0x000000, "Member 'UPNavModifierComponent_SetFailsafeExtent::InFailsafeExtent' has a wrong offset!");

}

